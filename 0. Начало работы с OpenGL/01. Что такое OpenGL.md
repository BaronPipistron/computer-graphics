***OpenGL (Open Graphics Library)*** - рассматривается как API, предоставляющий обширный набор функций, которые мы можем использовать для управления графикой и изображениями.

Если быть конкретнее, то OpenGL является спецификацией, разработанной и поддерживаемой **Khronos Group**

Спецификация OpenGL определяет, каким должен быть результат/вывод каждой функции, и как она должна выполняться. Реализация этой спецификации зависит уже от конкретных разработчиков. Поэтому разработанные версии OpenGL могут иметь разные реализации до тех пор, пока их результаты соответствуют спецификации (как следствие, являются одинаковыми для пользователя)

Библиотеки OpenGL обычно разрабатываются производителями видеокарт. Каждая видеокарта поддерживает определенные версии OpenGL, разработанные специально под эту линейку видеокарт. При использовании ПО от Apple, библиотека OpenGL поддерживается разработчиками из Apple, а в Linux существует целый набор версий графических поставщиков и адаптации от опенсорс-сообщества этих библиотек. Это значит, что каждый раз, когда OpenGL странно себя ведет, так как не должна, то это скорее всего вина производителей видеокарт или тех кто разрабатывал/поддерживает эту библиотеку

Всякий раз когда находится баг в реализации OpenGL, то это почти всегда решается обновлением драйверов видеокарты. Эти драйверы включают в себя последние версии OpenGL, который поддерживает наша видеокарта. *Это одна из основных причин, по которой всегда рекомендуется обновлять графические драйверы*

## Core-profile vs Непосредственный режим
Раньше использование OpenGL означало разработку в ***непосредственном режиме (так называемом "конвейере фиксированных функций")*** - просто в использовании методе для рисования графики. Большая часть функционала была скрыта внутри библиотеки и разработчики не имели контроля над тем, как OpenGL выполняет свои вычисления. Непосредственный режим прост в использовании и понимании, но крайне неэффективен. Поэтому начиная со спецификации версии 3.2 функционал непосредственного режима стали считать устаревшим. Этим мотивировали разработчиков перейти на разработку в режиме ***Core-Profile***, который является разделом спецификации OpenGL с полностью удаленным устаревшим функционалом

***Core-Profile*** заставляет нас применять современные техники. Когда мы пытаемся использовать устаревшие функции в режиме Core-Profile, OpenGL выбрасывает ошибку и останавливает рисование. Преимущества современного подхода - его гибкость и эффективность, но учить его сложнее

*При использовании функционала самых последних версий OpenGL только самые современные видеокарты смогут запустить наше приложение. Поэтому большинство разработчиков обычно ориентируются на более ранние версии OpenGL и только лишь при необходимости подключают функционал более новых версий*
## Расширения в OpenGL
Отличительная особенность OpenGL - поддержка расширений. Каждый раз, когда графическая компания выкатывает новую методику/большую оптимизацию для рендеринга, это часто встречается в расширении реализованном в драйверах. Если оборудование, на котором работает приложение, поддерживает такое расширение, то разработчик может использовать функционал этого расширения для более продвинутой и эффективной графики. Таким образом, можно использовать новые методы рендеринга, просто проверяя, поддерживается ли данное расширение видеокартой, не дожидаясь пока OpenGL добавит этот функционал в свою новую версию

Надо знать, доступны ла какие либо из этих расширений, прежде чем их использовать
```cpp
if (GL_ARB_extension_name) {
	// делаем крутые и современные вещи, поддерживаемы железом
} else {
	// расширение не поддерживается - делаем все по старинке
}
```

## Состояния в OpenGL
OpenGL сам по себе является большой *системой состояний*, которая содержит набор переменных, определяющих то, как OpenGL должен в текущий момент выполнять операции. Состояние OpenGL называют ***контекстом OpenGL***. При использовании OpenGL часто будем изменять его состояние, устанавливая некоторые параметры, манипулируя значениями из буфера, а затем выполняя рендеринг с использованием текущего контекста

Существуют ***функции изменения состояния***, которые изменяют контекст, и ***функции использования состояния***, которые выполняют указанные операции, в зависимости от текущего состояния OpenGL

## Объекты в OpenGL
Библиотеки OpenGL написаны на C, но допускают множество ответвлений с использованием других ЯП. Так как многие конструкции C не очень хорошо переводятся в другие высокоуровневые ЯП, то OpenGL был разработан с учетом некоторых абстракций. ***Одной из таких абстракций являются объекты***

***Объект в OpenGL - это набор параметров, представляющий подмножество состояния OpenGL.*** Например, может быть объект, представляющий настройки окна рисования; тогда мы можем изменить его размер, количество поддерживаемых цветов и т.д. Объект в OpenGL можно себе визуализировать как обычную структуру
```cpp
struct object_name {
	float option1;
	int option2;
	char[] name;
};
```

Всякий раз, когда мы хотим использовать объекты, они обычно выглядят следующим образом (с визуализацией контекста OpenGL как большой структуры)
```cpp
// состояние OpenGL
struct OpenGL_Context {
	// ...
	object_name* object_Window_Target;
	// ...
};
```

Затем
```cpp
// создаем объект
unsigned int objectId = 0;
glGenObject(1, &objectId);

// связываем (присваиваем) объект с контекстом
glBindObject(GL_WINDOW_TARGET, objectId);

// устанавливаем параметры объекта, который сейчас связан с GL_WINDOW_TARGET
glSetObjectOption(GL_WINDOW_TARGET, GL_OPTION_WINDOW_WIDTH, 800);
glSetObjectOption(GL_WINDOW_TARGET, GL_OPTION_WINDOW_HEIGHT, 600);

// возвращаем цеелвой контекст (переход к состоянию по умолчанию)
glBindObject(GL_WINDOW_TARGET, 0);
```

Этот фрагмент кода мы будем часто наблюдать при работе с OpenGL. Сначала мы создаем объект и сохраняем ссылку на него в качестве идентификатора (данные реального объекта хранятся за кулисами). Затем мы связываем объект (используя его идентификатор) с целевой локацией контекста (местоположение целевого объекта окна-пример определяется как `GL_WINDOW_TARGET`). Затем устанавливаем параметры окна и отсоединяем объект, устанавливая текущий идентификатор объекта целевого окна в 0. Установленные нами параметры сохраняются на объекте, на который ссылается `objectId`, и восстанавливаются, как только мы обратно связываем объект с `GL_WINDOW_TARGET`

Преимущество использования объектов - можем определить более одного объекта в нашем приложении, установить их параметры, и всякий раз, когда мы запускаем операцию, которая использует состояние OpenGL, мы связываем объект с нашими предпочтительными настройками. Например, есть объекты-контейнеры для хранения данных 3D-модели, и каждый раз, когда мы хотим нарисовать эту 3D-модель, мы связываем с необходимым контекстом объект, содержащий данные модели, которую мы хотим нарисовать (перед этим создав и установив параметры для этих объектов). Наличие нескольких объектов позволяет нам указывать множество моделей, и каждый раз, когда мы хотим нарисовать конкретную модель, перед рисованием мы просто связываем соответствующий объект (не устанавливая для него все параметры с нуля) с необходимым контекстом
